# JavaScript函数及作用域
[TOC]



### 1. 函数

> 函数就是将一段代码存到变量中，要用的时候就拿出来执行，这样可以避免代码冗余

- 函数声明：`function 函数名((){ //代码块 }`
	- 函数名其实就是变量名，只是习惯上称之为函数名

- 调用函数（执行函数的代码块）: `函数名(()`


函数表达式: `var fn = function() {};`

### 2. 函数传参
> 函数的参数的传递本质：实参给形参赋值

- 函数名(实际参数，简称实参)
- 函数声明 `function 函数名(形式参数，简称形参){  函数体代码  }`

- 调用函数 函数名(实际参数，简称实参)

### 3. 函数返回值
> 函数将自身的计算结果返回给调用者

return返回值时
1. 如果一个函数没有return关键字，默认返回值是undefined
2. 如果一个函数有return关键字，但是后面没有值，返回值是undefined
3. return关键字后面的代码都不会执行
4. 如果return关键字后面有值,此时函数的返回值就是return后面的值

函数的几种形态:
- 无参无返回函数：用的不多   
	- 单纯的执行一段代码
- 无参有返回函数：用的不多
- 有参无返回：用的不多的
- 有参有返回值：用的比较多    
	- 函数接收调用者传递的参数来进行运算来实现自己的功能，然后将实现后的结果返回给调用者

### 函数的

### 4. 作用域
> 变量起作用的范围

- 全局作用域
	- 变量在任何地方起作用,在函数外声明
- 局部作用域
	- 变量只在函数内部起作用,在函数内部声明
```javascript
    //1.全局变量
    var a = 10;
    function fn (  ) {
        console.log ( a );  //10
    }
    fn();

    //2.局部变量
    function fn1 (  ) {
        var num = 100;
        console.log ( num );  //100
    }
    fn1();
    console.log ( num );  //undefined
```

### 5. 作用域链
- 作用域这么来的
	- 默认情况下，我们的js代码处于全局作用域，当我们声明一个函数时，此时函数体会开辟一个局部作用域， 如果我们在这个函数体中又声明一个函数，那么又会开辟一个新的局部作用域，以此类推，就会形成一个作用域链
- 变量在作用域链上的访问规则
	- 就近原则：访问变量时，会优先访问的是在自己作用域链上声明的变量，如果自己作用域链上没有声明这个变量，那么就往上一级去找有没有声明这个变量，如果有就访问，如果没有就继续往上找有没有声明，直到找到0级作用域链上，如果有，就访问，如果没有就报错

![Alt text](./1535790436148.png)

```javascript
<script>
    /*1.作用域链由来：默认情况下，变量处在全局作用域（0级链），声明一个函数，会开辟一个局部作用域（1级链），
    如果在该函数中又声明一个函数，则会形成一个新的局部作用域（2级链）

    2.变量在作用域的访问原则：就近原则
        * 解释：访问变量时，首先会从自身所在的作用域查看是否声明，如果有声明则是该变量。如果没有声明，则会从父级
       作用域查看是否声明，如果有则是该变量，以此类推，如果父级没有，则继续往父级找，一直找到0级链，如果0级链还是没有
       则程序报错
     */

    var num = 10;//0级
    function fn1 (  ) {//0级，函数变量名自身还是0级的
        //局部作用域
         var num = 20;//1级链
        console.log ( 'fn1:' + num );

        function fn2 (  ) {//1级链，fn2自身还是在fn1的作用域下声明的
            //局部作用域
            var num = 30;//2级链
            console.log ( 'fn2:' + num );
        }
        fn2();
    }
    fn1();
    console.log ( '函数外' + num );
</script>
```

### 6. js预解析

- 预解析机制:
	- js在执行代码之前,会把变量的声明提升到所在作用域的最顶端
		- 将变量声明提前（相当于提前开辟内存空间），变量的赋值与函数的调用还是在原地
		- 函数的声明也会提前

好处: 
让函数可以在任何地方被调用

注意:
如果一个变量在声明的时候没有使用var,改变量无论写在声明位置都是全局的,不参与预解析 

### 
